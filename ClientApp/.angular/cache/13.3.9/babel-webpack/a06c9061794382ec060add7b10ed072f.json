{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { User, UserManager } from 'oidc-client';\nimport { BehaviorSubject, concat, from } from 'rxjs';\nimport { filter, map, mergeMap, take, tap } from 'rxjs/operators';\nimport { ApplicationPaths, ApplicationName } from './api-authorization.constants';\nimport * as i0 from \"@angular/core\";\nexport var AuthenticationResultStatus = /*#__PURE__*/(() => {\n  (function (AuthenticationResultStatus) {\n    AuthenticationResultStatus[AuthenticationResultStatus[\"Success\"] = 0] = \"Success\";\n    AuthenticationResultStatus[AuthenticationResultStatus[\"Redirect\"] = 1] = \"Redirect\";\n    AuthenticationResultStatus[AuthenticationResultStatus[\"Fail\"] = 2] = \"Fail\";\n  })(AuthenticationResultStatus || (AuthenticationResultStatus = {}));\n\n  return AuthenticationResultStatus;\n})();\nexport let AuthorizeService = /*#__PURE__*/(() => {\n  class AuthorizeService {\n    constructor() {\n      // By default pop ups are disabled because they don't work properly on Edge.\n      // If you want to enable pop up authentication simply set this flag to false.\n      this.popUpDisabled = true;\n      this.userSubject = new BehaviorSubject(null);\n    }\n\n    isAuthenticated() {\n      return this.getUser().pipe(map(u => !!u));\n    }\n\n    getUser() {\n      return concat(this.userSubject.pipe(take(1), filter(u => !!u)), this.getUserFromStorage().pipe(filter(u => !!u), tap(u => this.userSubject.next(u))), this.userSubject.asObservable());\n    }\n\n    getAccessToken() {\n      return from(this.ensureUserManagerInitialized()).pipe(mergeMap(() => from(this.userManager.getUser())), map(user => user && user.access_token));\n    } // We try to authenticate the user in three different ways:\n    // 1) We try to see if we can authenticate the user silently. This happens\n    //    when the user is already logged in on the IdP and is done using a hidden iframe\n    //    on the client.\n    // 2) We try to authenticate the user using a PopUp Window. This might fail if there is a\n    //    Pop-Up blocker or the user has disabled PopUps.\n    // 3) If the two methods above fail, we redirect the browser to the IdP to perform a traditional\n    //    redirect flow.\n\n\n    signIn(state) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.ensureUserManagerInitialized();\n        let user = null;\n\n        try {\n          user = yield this.userManager.signinSilent(this.createArguments());\n          this.userSubject.next(user.profile);\n          return this.success(state);\n        } catch (silentError) {\n          // User might not be authenticated, fallback to popup authentication\n          console.log('Silent authentication error: ', silentError);\n\n          try {\n            if (this.popUpDisabled) {\n              throw new Error('Popup disabled. Change \\'authorize.service.ts:AuthorizeService.popupDisabled\\' to false to enable it.');\n            }\n\n            user = yield this.userManager.signinPopup(this.createArguments());\n            this.userSubject.next(user.profile);\n            return this.success(state);\n          } catch (popupError) {\n            if (popupError.message === 'Popup window closed') {\n              // The user explicitly cancelled the login action by closing an opened popup.\n              return this.error('The user closed the window.');\n            } else if (!this.popUpDisabled) {\n              console.log('Popup authentication error: ', popupError);\n            } // PopUps might be blocked by the user, fallback to redirect\n\n\n            try {\n              yield this.userManager.signinRedirect(this.createArguments(state));\n              return this.redirect();\n            } catch (redirectError) {\n              console.log('Redirect authentication error: ', redirectError);\n              return this.error(redirectError);\n            }\n          }\n        }\n      });\n    }\n\n    completeSignIn(url) {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          yield this.ensureUserManagerInitialized();\n          const user = yield this.userManager.signinCallback(url);\n          this.userSubject.next(user && user.profile);\n          return this.success(user && user.state);\n        } catch (error) {\n          console.log('There was an error signing in: ', error);\n          return this.error('There was an error signing in.');\n        }\n      });\n    }\n\n    signOut(state) {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          if (this.popUpDisabled) {\n            throw new Error('Popup disabled. Change \\'authorize.service.ts:AuthorizeService.popupDisabled\\' to false to enable it.');\n          }\n\n          yield this.ensureUserManagerInitialized();\n          yield this.userManager.signoutPopup(this.createArguments());\n          this.userSubject.next(null);\n          return this.success(state);\n        } catch (popupSignOutError) {\n          console.log('Popup signout error: ', popupSignOutError);\n\n          try {\n            yield this.userManager.signoutRedirect(this.createArguments(state));\n            return this.redirect();\n          } catch (redirectSignOutError) {\n            console.log('Redirect signout error: ', popupSignOutError);\n            return this.error(redirectSignOutError);\n          }\n        }\n      });\n    }\n\n    completeSignOut(url) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.ensureUserManagerInitialized();\n\n        try {\n          const response = yield this.userManager.signoutCallback(url);\n          this.userSubject.next(null);\n          return this.success(response && response.state);\n        } catch (error) {\n          console.log(`There was an error trying to log out '${error}'.`);\n          return this.error(error);\n        }\n      });\n    }\n\n    createArguments(state) {\n      return {\n        useReplaceToNavigate: true,\n        data: state\n      };\n    }\n\n    error(message) {\n      return {\n        status: AuthenticationResultStatus.Fail,\n        message\n      };\n    }\n\n    success(state) {\n      return {\n        status: AuthenticationResultStatus.Success,\n        state\n      };\n    }\n\n    redirect() {\n      return {\n        status: AuthenticationResultStatus.Redirect\n      };\n    }\n\n    ensureUserManagerInitialized() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.userManager !== undefined) {\n          return;\n        }\n\n        const response = yield fetch(ApplicationPaths.ApiAuthorizationClientConfigurationUrl);\n\n        if (!response.ok) {\n          throw new Error(`Could not load settings for '${ApplicationName}'`);\n        }\n\n        const settings = yield response.json();\n        settings.automaticSilentRenew = true;\n        settings.includeIdTokenInSilentRenew = true;\n        this.userManager = new UserManager(settings);\n        this.userManager.events.addUserSignedOut(() => __awaiter(this, void 0, void 0, function* () {\n          yield this.userManager.removeUser();\n          this.userSubject.next(null);\n        }));\n      });\n    }\n\n    getUserFromStorage() {\n      return from(this.ensureUserManagerInitialized()).pipe(mergeMap(() => this.userManager.getUser()), map(u => u && u.profile));\n    }\n\n  }\n\n  AuthorizeService.ɵfac = function AuthorizeService_Factory(t) {\n    return new (t || AuthorizeService)();\n  };\n\n  AuthorizeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthorizeService,\n    factory: AuthorizeService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthorizeService;\n})();","map":null,"metadata":{},"sourceType":"module"}